---
title: Publicaciones avanzadas
slug: advanced-publications
date: 0013/01/02
number: 13.5
sidebar: true
contents: Aprenderemos patrones más avanzados para manipular publicaciones.|Veremos lo flexibles que son publicaciones y suscripciones. 
paragraphs: 36
---

A esta altura ya deberías tener una buena base de cómo interactúan las suscripciones y las publicaciones. Así que vamos a deshacernos de las ruedas de entrenamiento y examinar unos escenarios más avanzados.
 
### Publicar una Colección Varias Veces

En [nuestras primeras publicaciones en sidebar](/chapter/publications-and-subscriptions/), vimos algunas de los patrones más comunes de publicación y suscripción, y aprendimos cómo la función `_publishCursor` hizo muy fácil implementarlos en nuestros propios sitios.

Primero, vamos a recapitular exactamente qué hace por nosotros la función `_publishCursor`: toma todos los documentos que concuerdan con un cursor dado, y los envía a la colección del cliente *del mismo nombre*. Nótese que el nombre de la _publicación_ no está involucrado.

Esto significa que podemos tener _más de una publicación_ de cualquier colección, que enlaza al cliente y al servidor

Ya hemos encontrado este patrón en nuestro [capítulo de paginación](/chapter/pagination/), cuando publicamos un subconjunto paginado de todos los posts, además del post actual.

Otro caso de uso similar es publicar una *overview* de un largo conjunto de documentos, así como también los detalles completos de un simple ítem:
 
<%= diagram "doublecollection", "Publishing a collection twice", "pull-center" %>

~~~js
Meteor.publish('allPosts', function() {
  return Posts.find({}, {fields: {title: true, author: true}});
});

Meteor.publish('postDetail', function(postId) {
  return Posts.find(postId);
});
~~~

Ahora cuando el cliente se suscriba a esas dos publicaciones (utilizando `autorun` para asegurarnos que el `postId` correcto está siendo enviado a la suscripción `postDetail`), su colección `'posts'` es populada de dos fuentes: una lista de títulos y nombre de los autores por la primera suscripción, y los detalles completos de un post de la segunda.

Tal vez te hayas dado cuenta que el post publicado por `postDetail` es también publicado por `allPosts` (aunque sólo con un subconjunto de sus propiedades). Sin embargo, Meteor se hace cargo de la superposición fusionando los campos y asegurando que no haya posts duplicados.

Esto es genial, porque ahora cuando renderizemos la lista de los resúmenes de los posts, estaremos lidiando con objetos de datos que tienen sólo lo suficiente para mostrar lo que necesitamos. De todos modos, cuando renderizemos la página de un post entero, tenemos todo lo necesario para hacerlo. Por supuesto, tenemos que ocuparnos de que el cliente no espere que todos los campos estén disponibles en todos los posts en este caso -- eso es un error común!

Nótese que uno no está limitado a modificar las propiedades de los documentos. Podrías tranquilamente publicar las mismas propiedades en ambas publicaciones, pero ordenar los items de otra manera.
 
~~~js
Meteor.publish('newPosts', function(limit) {
  return Posts.find({}, {sort: {submitted: -1}, limit: limit});
});

Meteor.publish('bestPosts', function(limit) {
  return Posts.find({}, {sort: {votes: -1, submitted: -1}, limit: limit});
});
~~~
<%= caption "server/publications.js" %>

### Subscribing to a Publication Multiple Times

////
 
////
 
////
 
<%= diagram "subscribetwice", "Subscribing twice to one publication", "pull-center" %>

////
 
~~~js
Meteor.publish('posts', function(options) {
  return Posts.find({}, options);
});
~~~

////
 
~~~js
Meteor.subscribe('posts', {submitted: -1, limit: 10});
Meteor.subscribe('posts', {baseScore: -1, submitted: -1, limit: 10});
~~~

////
 
////
 
### Multiple Collections in a Single Subscription

////
 
////
 
////
 
////
 
////
 
////
 
////
 
<%= diagram "multiplecollections", "Two collections in one subscription", "pull-center" %>

~~~js
Meteor.publish('topComments', function(topPostIds) {
  return Comments.find({postId: topPostIds});
});
~~~

////
 
////
 
~~~js
Meteor.publish('topPosts', function(limit) {
  var sub = this, commentHandles = [], postHandle = null;
  
  // send over the top two comments attached to a single post
  function publishPostComments(postId) {
    var commentsCursor = Comments.find({postId: postId}, {limit: 2});
    commentHandles[post._id] = 
      Meteor.Collection._publishCursor(commentsCursor, sub, 'comments');
  }
    
  postHandle = Posts.find({}, {limit: limit}).observeChanges({
    added: function(id, post) {
      publishPostComments(post._id);
      sub.added('posts', id, post);
    },
    changed: function(id, fields) {
      sub.changed('posts', id, fields);
    },
    removed: function(id) {
      // stop observing changes on the post's comments
      commentHandles[id] && commentHandles[id].stop();
      // delete the post
      sub.removed('posts', id);
    }
  });
  
  sub.ready();
  
  // make sure we clean everything up (note `_publishCursor`
  //   does this for us with the comment observers)
  sub.onStop(function() { postsHandle.stop(); });
});
~~~

////
 
////
 
////
 
### Linking different collections

////
 
<%= diagram "linkedcollections", "One collection for two subscriptions", "pull-center" %>

////
 
////
 
////
 
////
 
~~~js
  Meteor.publish('videos', function() {
    var sub = this;
    
    var videosCursor = Resources.find({type: 'video'});
    Meteor.Collection._publishCursor(videosCursor, sub, 'videos');
    
    // _publishCursor doesn't call this for us in case we do this more than once.
    sub.ready();
  });
~~~

////
 
////
 
