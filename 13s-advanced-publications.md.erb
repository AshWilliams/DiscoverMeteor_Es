---
title: Publicaciones avanzadas
slug: advanced-publications
date: 0013/01/02
number: 13.5
sidebar: true
contents: Aprenderemos patrones más avanzados para manipular publicaciones.|Veremos lo flexibles que son publicaciones y suscripciones. 
paragraphs: 36
---

A esta altura ya deberías tener una buena base de cómo interactúan las suscripciones y las publicaciones. Así que vamos a deshacernos de las ruedas de entrenamiento y examinar unos escenarios más avanzados.
 
### Publicar una Colección Varias Veces

En [nuestras primeras publicaciones en sidebar](/chapter/publications-and-subscriptions/), vimos algunas de los patrones más comunes de publicación y suscripción, y aprendimos cómo la función `_publishCursor` hizo muy fácil implementarlos en nuestros propios sitios.

Primero, vamos a recapitular exactamente qué hace por nosotros la función `_publishCursor`: toma todos los documentos que concuerdan con un cursor dado, y los envía a la colección del cliente *del mismo nombre*. Nótese que el nombre de la _publicación_ no está involucrado.

Esto significa que podemos tener _más de una publicación_ de cualquier colección, que enlaza al cliente y al servidor

Ya hemos encontrado este patrón en nuestro [capítulo de paginación](/chapter/pagination/), cuando publicamos un subconjunto paginado de todos los posts, además del post actual.

Otro caso de uso similar es publicar una *overview* de un largo conjunto de documentos, así como también los detalles completos de un simple ítem:
 
<%= diagram "doublecollection", "Publishing a collection twice", "pull-center" %>

~~~js
Meteor.publish('allPosts', function() {
  return Posts.find({}, {fields: {title: true, author: true}});
});

Meteor.publish('postDetail', function(postId) {
  return Posts.find(postId);
});
~~~

Ahora cuando el cliente se suscriba a esas dos publicaciones (utilizando `autorun` para asegurarnos que el `postId` correcto está siendo enviado a la suscripción `postDetail`), su colección `'posts'` es populada de dos fuentes: una lista de títulos y nombre de los autores por la primera suscripción, y los detalles completos de un post de la segunda.

Tal vez te hayas dado cuenta que el post publicado por `postDetail` es también publicado por `allPosts` (aunque sólo con un subconjunto de sus propiedades). Sin embargo, Meteor se hace cargo de la superposición fusionando los campos y asegurando que no haya posts duplicados.

Esto es genial, porque ahora cuando renderizemos la lista de los resúmenes de los posts, estaremos lidiando con objetos de datos que tienen sólo lo suficiente para mostrar lo que necesitamos. De todos modos, cuando renderizemos la página de un post entero, tenemos todo lo necesario para hacerlo. Por supuesto, tenemos que ocuparnos de que el cliente no espere que todos los campos estén disponibles en todos los posts en este caso -- eso es un error común!

Nótese que uno no está limitado a modificar las propiedades de los documentos. Podrías tranquilamente publicar las mismas propiedades en ambas publicaciones, pero ordenar los items de otra manera.
 
~~~js
Meteor.publish('newPosts', function(limit) {
  return Posts.find({}, {sort: {submitted: -1}, limit: limit});
});

Meteor.publish('bestPosts', function(limit) {
  return Posts.find({}, {sort: {votes: -1, submitted: -1}, limit: limit});
});
~~~
<%= caption "server/publications.js" %>

### Subscribing to a Publication Multiple Times

////
 
////
 
////
 
<%= diagram "subscribetwice", "Subscribing twice to one publication", "pull-center" %>

////
 
~~~js
Meteor.publish('posts', function(options) {
  return Posts.find({}, options);
});
~~~

////
 
~~~js
Meteor.subscribe('posts', {submitted: -1, limit: 10});
Meteor.subscribe('posts', {baseScore: -1, submitted: -1, limit: 10});
~~~

////
 
////
 
### Multiple Collections in a Single Subscription

////
 
////
 
////
 
////
 
////
 
////
 
////
 
<%= diagram "multiplecollections", "Two collections in one subscription", "pull-center" %>

~~~js
Meteor.publish('topComments', function(topPostIds) {
  return Comments.find({postId: topPostIds});
});
~~~

////
 
////
 
~~~js
Meteor.publish('topPosts', function(limit) {
  var sub = this, commentHandles = [], postHandle = null;
  
  // send over the top two comments attached to a single post
  function publishPostComments(postId) {
    var commentsCursor = Comments.find({postId: postId}, {limit: 2});
    commentHandles[post._id] = 
      Meteor.Collection._publishCursor(commentsCursor, sub, 'comments');
  }
    
  postHandle = Posts.find({}, {limit: limit}).observeChanges({
    added: function(id, post) {
      publishPostComments(post._id);
      sub.added('posts', id, post);
    },
    changed: function(id, fields) {
      sub.changed('posts', id, fields);
    },
    removed: function(id) {
      // stop observing changes on the post's comments
      commentHandles[id] && commentHandles[id].stop();
      // delete the post
      sub.removed('posts', id);
    }
  });
  
  sub.ready();
  
  // make sure we clean everything up (note `_publishCursor`
  //   does this for us with the comment observers)
  sub.onStop(function() { postsHandle.stop(); });
});
~~~

////
 
////
 
////
 
### Enlazando colecciones diferentes

¿Qué mas puede darnos nuestro nuevo conocimiento sobre la flexibilidad de las suscripciones? Bueno, si no usamos `_publishCursor`, no tendremos la restricción de que la fuente de la colección en el servidor necesita tener el mismo nombre que la colección de destino en el cliente.

<%= diagram "linkedcollections", "One collection for two subscriptions", "pull-center" %>

Una razón por la que no querríamos hacer esto es la *Herencia de Tabla Simple*

Supongamos que quisiéramos referenciar varios tipos de objetos desde nuestros posts, cada uno alojado en campos comunes pero ligeramente diferentes en contenido. Por ejemplo, podríamos estar creando un motor de blogging al estilo de Tumblr en el que cada post posee el habitual ID, un timestamp, y el título. Pero también puede tener imágenes, videos, links o simplemente texto.

Podríamos guardar todos estos objetos en una colección llamada `'resources'` (recursos), usando un atributo de `type` que indique qué tipo de objeto son. (`video`, `image`, `link`, etc.)

Y aunque tendríamos una sola colección `Resources` en el servidor, podríamos transformar esa única colección en múltiples colecciones en el cliente, como `Videos`, `Images`, etc., con la siguiente porción de magia::
 
~~~js
  Meteor.publish('videos', function() {
    var sub = this;
    
    var videosCursor = Resources.find({type: 'video'});
    Meteor.Collection._publishCursor(videosCursor, sub, 'videos');
    
    // _publishCursor doesn't call this for us in case we do this more than once.
    sub.ready();
  });
~~~

Le estamos diciendo a `_publishCursor` que publique nuestros videos (como hacer un return) como lo haría el cursor, pero en lugar de publicar la colección `resources` en el cliente, pubilcamos de `resources` a `videos`.

¿Es una buena idea hacer esto? No estamos en posición de juzgarlo. De cualquier manera, es bueno saber qué es posible hacer en Meteor para sacarle el mayor provecho!
 
