---
title: RSS Feeds & APIs
slug: rss-api
date: 0015/01/01
number: 15
extra: true
points: 100
published: true
photoUrl: http://www.flickr.com/photos/ikewinski/8623402756/
photoAuthor: Mike Lewinski
contents: Aprende sobre ruteo en el servidor.|Crea un feed RSS.|Crea una simple GET API.
---

<% note do %>

### Introduciendo Capítulos Extra

El cuerpo principal del libro está enfocado en lo esencial: agregar cuentas de usuarios, configurar permisos, manejar publicaciones, mostrar errores, etc.

Pero mientras eso nos da una buena base, en el mundo real las aplicaciones no existen por sí solas: frecuentemente necesitan interactuar con varios servicios de terceros como proveedores de análisis de datos y otras APIs. Entonces, en estos capítulos extra, examinaremos algunos tópicos más avanzados, comenzando con cómo construir APIs para aplicaciones Meteor.

Nótese que encontrarán el código para estos capítulos en la [extra branch](https://github.com/DiscoverMeteor/Microscope/tree/extra) de GitHub.

<% end %>

Hasta ahora, sólo hemos comunicado a nuestra app a través del cliente. Incluso cuando usamos la consola dentro del navegador, estamos usando el código del lado de cliente de Meteor para comunicarnos con el servidor, y a través de él, con la base de datos.

Pero, ¿sabías que también es posible comunicarse directamente con el servidor?

Si has intentado acceder a una aplicación Meteor con Javascript deshabilitado, verías sólo una página en blanco. Eso es porque cuando un cliente se conecta por primera vez a una aplicación Meteor, el server no contesta con HTML o imágenes como lo haría una aplicación web "normal", sino que en su lugar envía el código Javascript de la aplicación, y es ese código el que carga todo el contenido cuando es ejecutado por el navegador.

Si deshabilitas Javascript, ese código nunca se ejecuta, haciendo que la app nunca cargue su contenido. Esto se vuelve problemático cuando intentamos construir cosas como feeds RSS o APIs, porque los lectores RSS no pueden ejecutar código Javascript, así que cómo se supone que podrían acceder al contenido de nuestra app?

### Ruteo del lado del servidor

We need a way to tell the server to send back actual data, and not JavaScript code. And this is where Iron Router's server-side routing comes in. 

Routing server-side is pretty similar to how things work client-side, although it isn't quite as full-featured. One notable difference is that Meteor doesn't (yet) support server-side templates. So instead of redirecting each route to a specific template, we'll include the code we want to output right there in the route definition. 

Let's start by building a simple “hello world” route, which we'll make available at `/feed.xml`. 

Since our `router.js` file lives in the `/lib` directory, it's already available on both the client and server. This means we can append our new server-side route to our existing route map, using the `where` option to specify that this will be a server-side route:

~~~js
Router.map(function() {
  this.route('home', {
    path: '/',
    controller: NewPostsListController
  });
  
  //...
  
  this.route('postSubmit', {
    path: '/submit',
    disableProgress: true
  });

  this.route('rss', {
    where: 'server',
    path: '/feed.xml',
    action: function() {
      this.response.write('hello world');
      this.response.end();
    }
  });
  
});

//...
~~~
<%= caption "lib/router.js" %>
<%= highlight "14~20" %>

If you tried out this route right now, you'd get an error. That's because we've assigned the `clearErrors()` filter to trigger on all routes, and that method happens to be only available to the client. 

So before anything else, let's make sure we deactivate this filter when on the server:

~~~js
if (Meteor.isClient)
  Router.before(function() { clearErrors() });
~~~

We can test if this route is working properly using the `curl` command line client:

~~~bash
$ curl "http://localhost:3000/feed.xml"
hello world
~~~
<%= caption "console" %>

We can see that we get the simple text response that we specified, rather than the complete website which we'd find at [http://localhost:3000/](http://localhost:3000/).

Iron Router supports a variety of options for server-side routing responses, notably setting headers and status codes on responses. You can read more about it in the [documentation](https://github.com/EventedMind/iron-router#server-side-routing).

<%= commit "15-1", "Hello world for server-side routing." %>

### Building The RSS Package From NPM

As you've probably guessed by now, the first thing we'll use server-side routes for is building an RSS feed for our `/new` view. Building our feed entirely by hand would quickly get tedious, so we'll use an existing [node package](https://npmjs.org/) to help generate it for us.

Unlike Atmosphere packages (which are specific to Meteor), Node Packaged Modules are not optimized for Meteor apps. A lot of them still work just fine though! 

To make use of the NPM RSS package, we'll create our own RSS local package to act as a wrapper. Create a new `rss` directory inside `/packages`, and add the following code to its `package.js`:

~~~js
Package.describe({
  summary: "RSS feed generator"
});
Npm.depends({rss: '0.0.4'});

Package.on_use(function (api) {
  api.add_files('rss.js', 'server');
  if(api.export)
    api.export('RSS');
});
~~~
<%= caption "packages/rss/package.js" %>

The key function here is `Npm.depends()`. This is what tells Meteor that we want to include the [RSS NPM package](https://npmjs.org/package/rss).

Once we've included the package, we can then load it using `Npm.require()` to make it globally available at the `RSS` namespace. Create a new `rss.js` file in the `/package/rss` directory, and type:

~~~js
RSS = Npm.require('rss');
~~~
<%= caption "packages/rss/rss.js" %>

As usual, don't forget to load your new package with:

~~~bash
meteor add rss
~~~

<% note do %>

### Local Packages

Local packages are a great way to isolate any third-party or generic code within your app, without having to go through the trouble of actually uploading a package to Meteorite. As a rule of thumb, it's a good idea to use local packages for any code that's not specific to your app. 

Not only does this keep things cleaner, but it'll make it easier to swap things out if, say, somebody comes out with a better RSS package for Meteor in the future. 

<% end %>

### Testing Our Feed

Let's flesh out our feed by giving it a title and a description:

~~~js
//...

this.route('rss', {
  where: 'server',
  path: '/feed.xml',
  action: function() {
    var feed = new RSS({
      title: "New Microscope Posts",
      description: "The latest posts from Microscope, the smallest news aggregator."
    });
    this.response.write(feed.xml());
    this.response.end();
  }
});

//...
~~~
<%= caption "lib/router.js" %>
<%= highlight "7~11" %>

Now if we browse to our feed URL, we should see the output of that simple feed XML:

~~~bash
$ curl "http://localhost:3000/feed.xml"
<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[New Microscope Posts]]></title><description><![CDATA[The latest posts from Microscope, the smallest news aggregator.]]></description><link>http://github.com/dylan/node-rss</link><generator>NodeJS RSS Module</generator><lastBuildDate>Tue, 25 Jun 2013 05:21:36 GMT</lastBuildDate></channel></rss>
~~~
<%= caption "console" %>

<%= commit "15-2", "Created RSS package, use it to create a rudimentary feed." %>

### Filling In Our Feed

Building our feed is relatively straightforward: we'll get the 20 latest posts, then iterate over them with Meteor's `forEach`. At each iteration, we'll use the RSS object's `item()` method to add the post to our feed:

~~~js
//...

this.route('rss', {
  where: 'server',
  path: '/feed.xml',
  action: function() {
    var feed = new RSS({
      title: "New Microscope Posts",
      description: "The latest posts from Microscope, the smallest news aggregator."
    });
    
    Posts.find({}, {sort: {submitted: -1}, limit: 20}).forEach(function(post) {
      feed.item({
        title: post.title,
        description: post.body,
        author: post.author,
        date: post.submitted,
        url: '/posts/' + post._id
      })
    });

    this.response.write(feed.xml());
    this.response.end();
  }
});

//...
~~~
<%= caption "lin/router.js" %>
<%= highlight "12~20" %>

<%= commit "15-3", "List each post in the feed." %>

<% note do %>

### RSS Polling

You'll note that we're displaying the 20 latest items. RSS readers poll a feed every X minutes to see if there are any new items (where X depends on the service). 

So if you expect a *lot* of activity on your site, you might want to increase that number to make sure items don't slip between the gaps, or alternatively always display items for the past 24 hours, no matter how much there are. 

<% end %>

### Linking Up Our Feed

The last step is making our feed discoverable by readers or by the browser (well, if browsers still cared about RSS feeds, that is). We only need to add a `<link>` tag to our header:

~~~html
<head>
  <title>Microscope</title>
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/feed.xml"/>
</head>
~~~
<%= caption "client/main.html" %>
<%= highlight "3" %>

We can now test that our RSS feed is working properly by downloading a RSS reader such as [Vienna](http://www.vienna-rss.org/) for Mac OS, [FeedDemon](http://www.feeddemon.com/) for Windows, or [Liferea](http://lzone.de/liferea/) for Linux and pointing it to `http://localhost:3000/feed.xml` (a web-based reader won't work unless you push the feed to a live server).

<%= commit "15-4", "Added an RSS link to the site header." %>

### A Simple API

We can take the exact same technique we just used for our RSS feed and use it to create a simple GET API, with a small differences: this time, one of our routes will take a parameter.

First, let's build a route that displays the latest posts:

~~~js
//...

this.route('rss', {
  //...
});

this.route('apiPosts', {
  where: 'server',
  path: '/api/posts',
  action: function() {
    var data = Posts.find().fetch();
    this.response.write(JSON.stringify(data));
    this.response.end();
  }
});

//...
~~~
<%= caption "lib/router.js" %>
<%= highlight "7~15" %>

All we're doing here is outputing the contents of our database by returning the stringified JSON data.

<%= commit "15-5", "Built a simple /api/posts route." %>

### Dealing With Parameters

So far so good. But in the real world, it wouldn't be very practical to return *all* posts for every API request. And it also doesn't make sense to return every single property of each posts. We need to add a limiting parameter, and we need to restrict the amount of data we output:

~~~js
//...

this.route('rss', {
  //...
});

this.route('apiPosts', {
  where: 'server',
  path: '/api/posts',
  action: function() {
    var parameters = this.request.query,
        limit = !!parameters.limit ? parameters.limit : 20,
        data = Posts.find({}, {limit: limit, fields: {title: 1, author: 1, url: 1, submitted: 1}}).fetch();

    this.response.write(JSON.stringify(data));
    this.response.end();
  }
});

//...
~~~
<%= caption "lib/router.js" %>
<%= highlight "7~15" %>

Let's break down what we're doing here. First, we're getting the current request's parameters with `this.request.query`. We then use the shorthand "if/else" statement syntax (`a ? b : c`) to check if `parameters.limit` is set. If it is, we use this as our `limit` variable, and if not we default to `20`. 

Finally, we use that `limit` variable along with a [field specificer](http://docs.meteor.com/#fieldspecifiers) object to build our `find()` query.

Let's give it a try!

~~~bash
$ curl http://localhost:3000/api/posts?limit=3
[
{"title":"Introducing Telescope","author":"Sacha Greif","url":"http://sachagreif.com/introducing-telescope/","submitted":1389055069603,"_id":"jBWwNNAhSDSxgaatC"},
{"title":"Meteor","author":"Tom Coleman","url":"http://meteor.com","submitted":1389044269603,"_id":"kYGexqxDpih6uQqN3"},
{"title":"The Meteor Book","author":"Tom Coleman","url":"http://themeteorbook.com","submitted":1389037069603,"_id":"QgJnFFNeyaeyyrQr8"}
]
~~~

<%= commit "15-5", "Limiting the /api/posts route." %>

### The Single Post API

To finish up, let's also extend our API to handle requests for a specific post:

~~~js
//...

this.route('apiPosts', {
  //...
});

this.route('apiPost', {
  where: 'server',
  path: '/api/posts/:_id',
  action: function() {
    var post = Posts.findOne(this.params._id);

    if(post){
      this.response.write(JSON.stringify(post));
    } else {
      this.response.writeHead(404, {'Content-Type': 'text/html'});
      this.response.write("Post not found.");
    }
    this.response.end();
  }
});

//...
~~~
<%= caption "lib/router.js" %>
<%= highlight "7~21" %>

We'll look up the post and return it if we found it. If we don't, we return a 404 header along with a "Post not found" message. We can now test that everything is working properly (make sure to replace `kYGexqxDpih6uQqN3d` by a valid `_id` of your own):

~~~bash
$ curl http://localhost:3000/api/posts/kYGexqxDpih6uQqN3d
{"title":"Meteor","userId":"2j3uJ859uT8FdQRz8","author":"Tom Coleman","url":"http://meteor.com","submitted":1389044269603,"commentsCount":0,"upvoters":[],"votes":0,"_id":"kYGexqxDpih6uQqN3"}
~~~

And that our error message appears as well:

~~~bash
$ curl http://localhost:3000/api/posts/1337
Post not found.
~~~

<%= commit "15-6", "Basic route for showing a post." %>

As of this writing, Meteor does not yet support *real* server-side rendering (i.e. rendering the same templates as on the client). But as we've just seen, that doesn't need to prevent us from building simple server-side routes for features such as RSS feeds or APIs. 
